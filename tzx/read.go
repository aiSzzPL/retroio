package tzx

// Rules and Definitions (https://www.worldofspectrum.org/TZXformat.html)
//
//  * Any value requiring more than one byte is stored in little endian format (i.e. LSB first).
//  * Unused bits should be set to zero.
//  * Timings are given in Z80 clock ticks (T states) unless otherwise stated.
//      1 T state = (1/3500000)s
//  * Block IDs are given in hex.
//  * All ASCII texts use the ISO 8859-1 (Latin 1) encoding; some of them can have several lines, which
//    should be separated by ASCII code 13 decimal (0D hex).
//  * You might interpret 'full-period' as ----____ or ____----, and 'half-period' as ---- or ____.
//    One 'half-period' will also be referred to as a 'pulse'.
//  * Values in curly brackets {} are the default values that are used in the Spectrum ROM saving
//    routines. These values are in decimal.
//  * If there is no pause between two data blocks then the second one should follow immediately; not
//    even so much as one T state between them.
//  * This document refers to 'high' and 'low' pulse levels. Whether this is implemented as ear=1 and
//    ear=0 respectively or the other way around is not important, as long as it is done consistently.
//  * Zeros and ones in 'Direct recording' blocks mean low and high pulse levels respectively.
//    The 'current pulse level' after playing a Direct Recording block of CSW recording block
//    is the last level played.
//  * The 'current pulse level' after playing the blocks ID 10,11,12,13,14 or 19 is the opposite of
//    the last pulse level played, so that a subsequent pulse will produce an edge.
//  * A 'Pause' block consists of a 'low' pulse level of some duration. To ensure that the last edge
//    produced is properly finished there should be at least 1 ms. pause of the opposite level and only
//    after that the pulse should go to 'low'. At the end of a 'Pause' block the 'current pulse level'
//    is low (note that the first pulse will therefore not immediately produce an edge). A 'Pause' block
//    of zero duration is completely ignored, so the 'current pulse level' will NOT change in this case.
//    This also applies to 'Data' blocks that have some pause duration included in them.
//  * An emulator should put the 'current pulse level' to 'low' when starting to play a TZX file, either
//    from the start or from a certain position. The writer of a TZX file should ensure that the 'current
//    pulse level' is well-defined in every sequence of blocks where this is important, i.e. in any
//    sequence that includes a 'Direct recording' block, or that depends on edges generated by 'Pause'
//    blocks. The recommended way of doing this is to include a Pause after each sequence of blocks.
//  * When creating a 'Direct recording' block please stick to the standard sampling frequencies of 22050
//    or 44100 Hz. This will ensure correct playback when using PC's sound cards.
//  * The length of a block is given in the following format: numbers in square brackets [] mean that the
//    value must be read from the offset in the brackets. Other values are normal numbers.
//    Example: [02,03]+0A means: get number (a word) from offset 02 and add 0A. All numbers are in hex.
//  * General Extension Rule: ALL custom blocks that will be added after version 1.10 will have the length
//    of the block in first 4 bytes (long word) after the ID (this length does not include these 4 length
//    bytes). This should enable programs that can only handle older versions to skip that block.
//  * Just in case:
//      MSB = most significant byte
//      LSB = least significant byte
//      MSb = most significant bit
//      LSb = least significant bit

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"log"

	"github.com/pkg/errors"

	"github.com/mrcook/tzxit/tape"
	"github.com/mrcook/tzxit/tzx/blocks"
)

const (
	supportedMajorVersion = 1
	supportedMinorVersion = 20
)

// Header is the first block of data found in all TZX files.
//
// The file is identified with the first 7 bytes being `ZXTape!`, followed by the
// _end of file_ byte `26` (`1A` hex). This is followed by two bytes containing
// the major and minor version numbers of the TZX specification used.
type header struct {
	Signature    [7]byte // must be `ZXTape!`
	Terminator   uint8   // End of file marker
	MajorVersion uint8   // TZX major revision number
	MinorVersion uint8   // TZX minor revision number
}

// A Reader is an io.Reader that can be read to retrieve the binary
// data from a TZX format file.
//
// TZX files store the header information at the start of the file, followed
// by zero or more data blocks. Some TZX files include an ArchiveInfo block,
// which is always stored as the first block, directly after the header.
type Reader struct {
	header  // valid after NewReader
	archive blocks.ArchiveInfo
	reader  *tape.Reader
	blocks  []Block
}

// Block is an interface for TZX data blocks
type Block interface {
	Id() uint8
	Name() string
	ToString() string
}

// NewReader creates a new Reader reading the given reader.
//
// It is the caller's responsibility to call Close on the Reader when done.
//
// The Reader.Header fields will be valid in the Reader returned.
func NewReader(r io.Reader) (*Reader, error) {
	t := &Reader{}
	t.reader = tape.NewReader(r)

	if err := t.readHeader(); err != nil {
		return nil, err
	} else if err := t.header.valid(); err != nil {
		return nil, err
	}

	return t, nil
}

// Read the TZX data blocks.
func (r *Reader) ReadBlocks() error {
	if err := r.readBlocks(); err != nil {
		return err
	}
	return nil
}

// DisplayTapeMetadata print all the tape metadata; archive info, data blocks, etc., to the terminal.
func (r Reader) DisplayTapeMetadata() {
	fmt.Println("Tzxit processing complete!")
	fmt.Println()
	fmt.Println("ARCHIVE INFORMATION:")
	fmt.Println(r.archive.ToString())

	fmt.Println("DATA BLOCKS:")
	for i, block := range r.blocks {
		fmt.Printf("#%d %s\n", i+1, block.ToString())
	}

	fmt.Println()
	fmt.Printf("TZX revision: v%d.%d\n", r.MajorVersion, r.MinorVersion)
}

// readHeader processes the TZX header data and validates that the tape format is correct.
func (r *Reader) readHeader() error {
	r.header = header{}
	data := r.reader.ReadBytes(10)

	buffer := bytes.NewBuffer(data)
	err := binary.Read(buffer, binary.LittleEndian, &r.header)
	if err != nil {
		return fmt.Errorf("binary.Read failed: %v", err)
	}

	if string(r.header.Signature[:]) != "ZXTape!" {
		return fmt.Errorf("TZX file is not in correct format")
	}

	return nil
}

// readBlocks processes all the TZX data blocks.
func (r *Reader) readBlocks() error {
	for {
		blockID, err := r.reader.ReadByte()
		if err != nil {
			if err != io.EOF {
				return err
			}
			break
		}
		r.readBlockData(blockID)
	}
	return nil
}

// readBlockData processes the data for the given block ID.
func (r *Reader) readBlockData(id byte) {
	switch id {
	case 0x10:
		ssd := &blocks.StandardSpeedData{}
		ssd.Read(r.reader)
		r.blocks = append(r.blocks, ssd)
	case 0x11:
		tsd := &blocks.TurboSpeedData{}
		tsd.Read(r.reader)
		r.blocks = append(r.blocks, tsd)
	case 0x12:
		pt := &blocks.PureTone{}
		pt.Read(r.reader)
		r.blocks = append(r.blocks, pt)
	case 0x13:
		sop := &blocks.SequenceOfPulses{}
		sop.Read(r.reader)
		r.blocks = append(r.blocks, sop)
	case 0x14:
		pd := &blocks.PureData{}
		pd.Read(r.reader)
		r.blocks = append(r.blocks, pd)
	case 0x15:
		dr := &blocks.DirectRecording{}
		dr.Read(r.reader)
		r.blocks = append(r.blocks, dr)
	case 0x18:
		cr := &blocks.CswRecording{}
		cr.Read(r.reader)
		r.blocks = append(r.blocks, cr)
	case 0x19:
		gd := &blocks.GeneralizedData{}
		gd.Read(r.reader)
		r.blocks = append(r.blocks, gd)
	case 0x20:
		pt := &blocks.PauseTapeCommand{}
		pt.Read(r.reader)
		r.blocks = append(r.blocks, pt)
	case 0x21:
		gs := &blocks.GroupStart{}
		gs.Read(r.reader)
		r.blocks = append(r.blocks, gs)
	case 0x22:
		ge := &blocks.GroupEnd{}
		ge.Read(r.reader)
		r.blocks = append(r.blocks, ge)
	case 0x23:
		jt := &blocks.JumpTo{}
		jt.Read(r.reader)
		r.blocks = append(r.blocks, jt)
	case 0x24:
		ls := &blocks.LoopStart{}
		ls.Read(r.reader)
		r.blocks = append(r.blocks, ls)
	case 0x25:
		ls := &blocks.LoopEnd{}
		ls.Read(r.reader)
		r.blocks = append(r.blocks, ls)
	case 0x26:
		cs := &blocks.CallSequence{}
		cs.Read(r.reader)
		r.blocks = append(r.blocks, cs)
	case 0x27:
		rs := &blocks.ReturnFromSequence{}
		rs.Read(r.reader)
		r.blocks = append(r.blocks, rs)
	case 0x28:
		s := &blocks.Select{}
		s.Read(r.reader)
		r.blocks = append(r.blocks, s)
	case 0x2a:
		st := &blocks.StopTapeWhen48kMode{}
		st.Read(r.reader)
		r.blocks = append(r.blocks, st)
	case 0x2b:
		sl := &blocks.SetSignalLevel{}
		sl.Read(r.reader)
		r.blocks = append(r.blocks, sl)
	case 0x30:
		td := &blocks.TextDescription{}
		td.Read(r.reader)
		r.blocks = append(r.blocks, td)
	case 0x31:
		m := &blocks.Message{}
		m.Read(r.reader)
		r.blocks = append(r.blocks, m)
	case 0x32:
		ai := blocks.ArchiveInfo{}
		ai.Read(r.reader)
		r.archive = ai
	case 0x33:
		ht := &blocks.HardwareType{}
		ht.Read(r.reader)
		r.blocks = append(r.blocks, ht)
	case 0x35:
		ci := &blocks.CustomInfo{}
		ci.Read(r.reader)
		r.blocks = append(r.blocks, ci)
	case 0x5a: // (90 dec, ASCII Letter 'Z')
		gb := &blocks.GlueBlock{}
		gb.Read(r.reader)
		r.blocks = append(r.blocks, gb)
	default:
		// probably ID's 16,17,34,35,40 (HEX)
		log.Fatalf("ID 0x%02X is deprecated/not supported", id)
	}
}

// Validates the TZX header data.
func (h header) valid() error {
	var validationError error

	sig := [7]byte{}
	copy(sig[:], "ZXTape!")
	if h.Signature != sig {
		validationError = errors.Wrapf(validationError, "Incorrect signature, got '%s'", h.Signature)
	}

	if h.Terminator != 0x1a {
		validationError = errors.Wrapf(validationError, "Incorrect terminator, got '%b'", h.Terminator)
	}

	if h.MajorVersion != supportedMajorVersion {
		validationError = errors.Wrapf(validationError, "Invalid version, got v%d.%d", h.MajorVersion, h.MinorVersion)
	} else if h.MinorVersion < supportedMinorVersion {
		fmt.Printf(
			"WARNING! Expected TZX v%d.%d but got v%d.%d. This may lead to unexpected data or errors.\n",
			supportedMajorVersion,
			supportedMinorVersion,
			h.MajorVersion,
			h.MinorVersion,
		)
		fmt.Println()
	}

	return validationError
}
